Сессия сама знает, работает она локально или не локально. Потом это будет выделено в отдельный модуль около сессии.

Версия 1, без сервера:

- Мержим текущий дев в main. Пересобираем по новым рельсам playPage, переименовывая его в Test/Debug.
- Переносим gameClient из components в apps?
- Добавляем в тип SLink указатель на проект (вводим внешние ссылки на другие проекты)
- Заводим шаблон коллекции. В нем указываем ссылку на коллекцию, а так же в какой кардтайп превращаются и в какой плейс кладутся карточки.
- Хардкодим контент
- Заводим техническую структуру NFT { collection, name, image }, сводим к ней список нфт юзера
- На старте игры, имея контент, фильтруем все нфт юзера, пропуская только те, которые определены в collections. Те, которые прошли, кладем в session.nfts
- Когда вызываем start у сессии, для каждой из нфт создаем карту кардтайпа из сеттингов и кладем в соответствующий плейс.
- На кардтайпах заводим структуру NFT c двумя булами (override title, override image). Она компилится только в веб. Ее задача - помочь сформировать конфиг оверрайдов
- Формируем конфиг оверрайдов. Он состоит из двух частей - данные всех карточек и оверрайдовые поля темплейтов.
- Когда юнити загрузилось отправляем сначала контент, потом оверрайды, потом стейт. 

Версия 2, с сервером:

API

login (project, pubkey)
Возвращает идентификатор матча или ничего

game_create (project, pubkey, version)
Требует идентификатор игры

get_game (project, game_id)

Игра: {
	player: %pubkey,
	status: 'ongoing',
	nfts: [],
	log: [],
}

game_leave (project, pubkey, game_id)
game_add_log (project, pubkey, game_id, log)



Структура базы данных

settings
versions
games


План

1) Поднимаем отдельную базу game_%projectName для каждого проекта
2) Создаем на сервере sage project.release, который принимает набор контентов и релизит это в versions с инкрементированием версии
3) Стартовая страничка пустая, если не выбрал игру, рисуем кнопку "поиграть в эклипс"
4) Если выбрана игра, то требуем залогиниться через кошелек.
5) Если кошелек справился, то выполняем game.login с указанием игры, получаем статус.
6) Игры нет, нажимаем кнопку "создать игру", вызываем game.create
7) Получаем ответ на это игру
8) Теперь по игровому действию вызываем add_log. В ответ на него посылаем новый лог.